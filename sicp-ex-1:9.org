*Exercise 1.9:* Each of the following two procedures defines a
method for adding two positive integers in terms of the procedures
`inc', which increments its argument by 1, and `dec', which
decrements its argument by 1.
Using the substitution model, illustrate the process generated by
each procedure in evaluating `(+ 4 5)'.  Are these processes
iterative or recursive?

    #+header: :eval "no"
    #+begin_src scheme
      (define (+ a b)
        (if (= a 0)
            b
            (inc (+ (dec a) b))))

      (+ 3 2)
      (inc (+ (dec 3) 2))
      (inc (+ 2 2))
      (inc (inc (+ (dec 2) 2)))
      (inc (inc (+ 1 2)))
      (inc (inc (inc (+ (dec 1) 2))))
      (inc (inc (inc (+ 0 2))))
      (inc (inc (inc 2)))
      (inc (inc 3))
      (inc 4)
      5
    #+end_src

The procudure above is linear recursive. Every function call
that this procedure generates after it is called depends on the
functions enclosing it. As the text itself says, it is
"characterized by a chain of deferred operations".

    #+header: :eval "no"
    #+begin_src scheme
      (define (+ a b)
        (if (= a 0)
            b
            (+ (dec a) (inc b))))

      (+ 3 2)
      (+ (dec 3) (inc 2))
      (+ 2 3)
      (+ (dec 2) (inc 3))
      (+ 1 4)
      (+ (dec 1) (inc 4))
      (+ 0 5)
      5
    #+end_src

The procedure above is iterative recursive. At every step, it has
all of the information it needs. 

In general, a recursive procedure will operate on a call to itself.
For example, the first procudure increments a call to `(+ (dec a)
b)'. This results in the chain of deferred operations. Scheme's
applicative-order interpreter attempts to evaluate the innermost
function calls first, which happen to be `(dec a)' and then `(+ x
b)' where `x' is the atomic result of `(dec a)'. This second call
results in an expansion, which must be evaluated again, which
will result in another expansion. The entire time the stack
grows, the first call of the first procedure cannot increment its
argument until it is evaluated as an atom. This will only happen
at the very end of the process. So, a recursive process 'expands'
until the innermost function call can be evaluated into atom, at
which point the nested function calls evaluate the atom until the
entire expression is evaluated into an atom. Every call to the
procedure in this process except the first depends on its
enclosing functions to produce an accurate answer. Thus, we
cannot simply stop the process at any time, extract the innermost
function call and expect the result to be the same as if we had
let the process fully evaluate.

An iterative procedure, on the other hand, does not operate on
calls to itself. This means that there are no deferred
operations. The iterative procedure simply calls itself with
new arguments and the computation can continue from there. An
iterative processs, unlike a recursive process, can pause,
extract the innermost call to itself, evaluate it and still get
the same result as it would get if it ran its course without
interference. An iterative call has all the information it needs
in its arguments. It does not depend on information from its
enclosing functions.


